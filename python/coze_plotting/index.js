
// 1. 设置内容
let content = `分镜图1：室内自然夜景，"胖橘猫"身穿蓝白相间的条纹睡袍，疲惫地坐在一款深棕色沙发上。台灯散发出柔和的黄光，投射在"胖橘猫"苍白的面庞和眼睛上。"胖橘猫"眼皮沉重，倦意十足，右手微微用力握着一本翻开到中间的《新手父母指南》，书页好像随时会因为松手而滑落。
分镜图2：镜头转到沙发旁，一个白木色宝宝床中，三只没有盖住头的新生"小橘猫"平安地睡着。床头的圆形小夜灯散射着暖黄色的光环，给这个安静的夜晚增添了份温馨。"小橘猫"们的身上盖着以浅蓝色为底，点缀着小白星的棉质婴儿被。
分镜图3：一只眼睛初开的"小橘猫"上，它四肢舒展，嘴巴轻轻吮吸着空气。此时，"胖橘猫"小心地从绒布沙发上站起，脚步轻盈，温柔地将这只饿了的"小橘猫"抱入怀中，准备给它夜间的食物。
分镜图4："胖橘猫"在明亮而简约的厨房里，右手拿着透明的奶瓶正放在一个白色的温奶器旁，左手轻抚着"小橘猫"的背部，焦急的眼神不断检查温奶器上的温度指示。此外，厨房墙壁上的圆形时钟显示现在是深夜两点，厨房充满夜间的安静与温暖氛围。
分镜图5："胖橘猫"给橘黄色的"小橘猫"喂奶，"小橘猫"用力地吸吮奶瓶，动作贪婪而迫切。"胖橘猫"倚靠在带有浅绿色马赛克瓷砖的橱柜上，黄色的室内灯光映照出其脸上的笑意与满足感。眼皮沉重的"胖橘猫"趁这个机会打了个小盹。
分镜图6：喂奶结束后，"胖橘猫"手中拿着一条小巧的浅绿色小毛巾，轻柔地为"小橘猫"拍打着背部，"小橘猫"被放在有着淡黄色软垫的橙色婴儿椅上。"胖橘猫"专注的目光和动作尽显父爱，而从半开的窗帘透进来的银白月光把这酣畅淋漓的父子画面衬托得更加温馨。
分镜图7："胖橘猫"把刚刚喂奶的"小橘猫"轻轻放回到那个白木色的宝宝床，它随即转身，面向另一个正处于哭闹状态的"小橘猫"。"胖橘猫"眉头微皱，但眼神温柔，充满了耐心和关切，体现出一个不知疲倦的慈父形象。
分镜图8：这个场景突出了"胖橘猫"安抚第二个哭闹的"小橘猫"的情景，"胖橘猫"在一个闪着橙色小铃铛的彩色塑料玩具前，用玩具引起"小橘猫"的注意，尽力安慰它。厨房的灯光昏黄柔和，"胖橘猫"的面庞在这个过程中显得既宠溺又郑重。
分镜图9：夜晚的宁静再次降临，这一分镜要表现"胖橘猫"对每个"小橘猫"细致的关照，怀里抱着包有小蓝毯的另一只"小橘猫"，"胖橘猫"轻轻地逐一检查宝宝床上的"小橘猫"们，确保它们都安然入睡。屋内装饰简单，但透漏出家的温暖和关爱。
分镜图10："胖橘猫"疲倦地拖着沉重的步伐回到沙发，刚想躺下，沙发边地上的一双蓬松的灰白相间的猫毛拖鞋和沙发角落里那本孤单地躺着的《新手父母指南》反映了屋主繁忙又温馨的生活状态。
分镜图11：在夜深人静的居室内，刚刚沉沉入睡的"胖橘猫"被边上宝宝床中传来的一个小小的哭声惊醒。"胖橘猫"迅速坐起，一双忧心忡忡的大眼睛在昏黄的灯光下显得格外明亮。它的表情交织着焦虑和关爱，马上准备再次照顾需要他的小宝贝。
分镜图12："胖橘猫"穿着一件轻柔的蓝色小睡衣，轻轻摩挲一只哭泣的"小橘猫"的小后背，试图使其感到舒适和安心。随着"胖橘猫"父亲般的抚触，室内充满了柔和的光线，"小橘猫"的啼哭声逐渐减弱，终于止住了。
分镜图13："胖橘猫"现在在摇晃着挂在小床上的一串彩虹色的毛线球，为的是分散"小橘猫"的注意力，帮助它放松下来。房间里的气氛被蓝色的夜灯照得柔和而宁静，安祥的氛围让这个夜晚的烦恼渐渐消散。
分镜图14：这一画面"胖橘猫"小心翼翼地将刚刚安抚好的"小橘猫"放回到温暖的宝宝床中。用轻薄的浅蓝色小被轻轻覆盖在"小橘猫"的身上，确保其保持温暖。房内一切都又恢复了往日的宁静，只剩下"胖橘猫"微弱的脚步声和窗外夜风的私语。
分镜图15：最后的画面是"胖橘猫"站在宝宝床边，眼里满是对睡梦中"小橘猫"无尽的喜爱和守护。随后它转身，向着房间内的落地窗走去，目光穿过玻璃窗户，凝望外面深邃的夜色。周围一片安静，只有遥远的星光在夜空中闪烁，映照出"胖橘猫"对此刻宁静生活的珍视。
`

// 2. 根据 '分镜图图' 标识进行分割
let contentArr = content
  .split("分镜图")
  .map(
    (item) =>
      `请严格根据Prompt要求的内容分析绘制分镜图，分镜图描述中"xxx"描绘的信息为角色，小橘猫是刚出生的小猫咪，需要严格按照角色形象进行绘制，同时需要确保描绘的动物角色都需要拟人化绘制。画面描述：分镜图${item}`
  );
// """"胖橘猫""""的外观描述为：形象应该是圆润、健壮，体现出一种成熟稳重的风范。他的毛色可能会很丰富，主要以温暖的橘色调为主。
contentArr.shift();
console.log(contentArr);

// 根据类名找到元素
let input_dom = document.querySelector(
  ".M6SqVKIgxzkG926qHtuX .semi-input-textarea.semi-input-textarea-autosize"
);

let intervalId = null;
var isStop = false;

const func = async (i = 0, cycle = 0) => {
  // 如果index已经超过数组长度，那么终止递归
  if (i >= contentArr.length) return;
  if (isStop) return;

  // 4.1. 填入内容
  let setValue = Object.getOwnPropertyDescriptor(
    window.HTMLTextAreaElement.prototype,
    "value"
  ).set;

const content = cycle === 0 ? contentArr[i] : contentArr[i].replace('分析绘制分镜图', '重新绘制分镜图')

  setValue.call(input_dom, content);

  let event = new Event("input", { bubbles: true });

  input_dom.dispatchEvent(event);

  console.time("timer");
  // 4.2. 等待2s
  await new Promise((resolve) => setTimeout(resolve, 5000));
  console.timeEnd("timer");

  // 4.3. 点击元素
  document.querySelector(".lgvvFMU_ZtEgFG2Q14nX").click();

  console.time("timer1");

  // 4.4. 等待10s，检查元素是否存在
  await new Promise(async (resolve) => {
    clearInterval(intervalId);
    intervalId = setInterval(() => {
      let isLoading =
        document.querySelector(".HtE_QDTDO5s6h3FZ5MPz").offsetHeight === 0;
    if (isStop) return;

      console.log("是否加载中: ", isLoading);
      if (isLoading) {
        clearInterval(intervalId);
        resolve();
      }
    }, 1000 * 10);
  });
  console.timeEnd("timer1");
  // 递归调用：根据cycle数，选择是进入下一循环还是进入下个内容
  cycle < 1 ? await func(i, cycle + 1) : await func(i + 1);
};

func();

