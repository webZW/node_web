
// 1. 设置内容
let content = `分镜图1："胖橘猫"整理装备,"胖橘猫"穿着黑色的战斗背心，上面镶有橘色条纹。他坐在一个木制凳子上，正在打开一个油布包，里面整齐地放着手枪、步枪弹匣和几个闪光弹。他用爪子轻巧地检查每一件装备，确保它们处于最佳状态。
分镜图2：队伍集结,在混凝土墙壁和金属门构成的简易房间内，"胖橘猫"站在前排中间，他的身边站着四名武装到牙齿的士兵，人类特种部队成员。他们都穿着统一的军服，装备着头盔和夜视镜，并高举手中的突击步枪，脸上是紧张却期待的表情。
分镜图3：快速前进,"胖橘猫"和队伍在一条长长的，两侧布满沙袋的走廊里前进。走廊两边是铁门和贴着脱落油漆的墙壁。指挥官"胖橘猫"手持步枪，以蹲姿领先队伍，身体保持低姿态，眼神警惕地注视着前方的拐角。
分镜图4：激烈的交火,"胖橘猫"背靠着一个被弹痕斑斑的混凝土掩体，与敌人交火。他一只手稳稳握着亮银色的手枪，另一只手准备投掷一个手雷。手雷外壳上刻有模糊的军队标志。掩体上方飞舞着橙色的火花，子弹擦身而过，凝固成一道发光的轨迹。
分镜图5：烟雾中的覆盖,厚重的灰色烟雾弥漫在图画中央，"胖橘猫"的轮廓隐约可见。他正从一个烟雾中的缺口快速跑出，躲避子弹，前方是一个敞开的木门，透过门可以看到外面亮光闪烁的开阔区域，他的队友在烟雾的另一边提供掩护火力。
分镜图6：紧急救援,一名队员抱着胳膊倒在地上，脸上带着痛苦的表情。"胖橘猫"迅速跪下在他旁边，展开一个红色急救包，手中拿着白色纱布和止血带。四周是散落的子弹壳和碎石，背景中可以看到模糊的战斗场面。
分镜图7：强力突破,画面中的"胖橘猫"表情骁勇，领先在前，他用力踹开了一个破旧的木门，从里面蹿出。门板四分五裂，木屑横飞。"胖橘猫"手里握着一把发光的冲锋枪，枪口正对敌人。火花在部队的突进中四散飞溅。
分镜图8：险境,视角转换到"胖橘猫"上方，他被敌人围在一个弹坑中，敌人的黑色影子从四面八方逼近，他的表情是决然的，手里握紧了步枪，眼神中闪烁着不屈的光芒，身后是被子弹掏空的土墙。
分镜图9：狙击瞬间,"胖橘猫"躺在一片废墟的顶端，穿着迷彩斑块的狙击服，腹下是一张展开的迷彩布。他持狙击枪，瞄准镜中反射出远处敌人的影像，完美隐蔽在环境当中。"胖橘猫"的尾巴轻微摆动，聚焦瞄准的眼神中流露出专业的冷静。
分镜图10：紧急拆弹,场景聚焦在一个复杂的炸弹装置上，上面滴答作响的计时器逐秒倒数。"胖橘猫"佩戴防爆背心，正小心翼翼地用一把线钳剪掉一个蓝色的电线。他的额头上有细密的汗珠，旁边放着一个炸弹解除工具包。背景是一个昏暗的储存室。
分镜图11：对峙的紧张,在一座废弃仓库的狭窄过道里，两侧铁皮箱堆叠着。"胖橘猫"靠着箱子，警惕地凝视前方。他的手臂肌肉紧绷，握着黑色的突击步枪，准备随时应对潜藏在阴影中的敌人。紧张的气氛几乎让时间凝固。
分镜图12：近身肉搏,"胖橘猫"和一名戴着面具的敌人在地面上翻滚着格斗。"胖橘猫"的脸部表情呈现出野性的斗志，他用自己的重量压制对方，而手中的军刀紧贴敌人的喉咙。地板上散乱的弹壳和昏暗的灯光增加了战斗的残酷感。
分镜图13：危机中的转机,在一个阴暗的房间里，"胖橘猫"背靠着一个破损的墙壁，他身边的子弹已全部耗尽。面对未见数的敌人，"胖橘猫"面露微笑，从口袋中掏出最后的秘密武器——一颗小巧的手榴弹，准备以一记惊喜反击。
分镜图14：逃出危险,一栋楼房的结构被爆炸破坏，正在崩塌。在浓烟和尘土之中，"胖橘猫"提着一只显得有些笨重的冲锋枪，身体倾斜，带领着队友从楼层的窗口奋力跳出。他们的脸上既有逃脱即将倒塌建筑的紧急感，又有幸存的庆幸。
分镜图15：队伍胜利庆祝,夕阳的余晖洒在了一个宽广的停机坪上，五名特种部队队员围成一圈，他们高举手中的枪械，头盔已经摘下挂在腰间。中间的"胖橘猫"以站立的姿态，挺胸抬头，耀眼的日光反射在他的勋章上。
分镜图16：勋章颁发仪式,在一个拥有国旗和部队旗帜的室内仪式大厅里，"胖橘猫"站在一个讲台前。一位身着军装，佩戴着多枚勋章的长官为他戴上一枚闪亮的勋章，背景中其他士兵和观众鼓掌致敬。
分镜图17：宁静的片刻,在一天的战斗结束后，"胖橘猫"独自一人坐在基地的屋顶上，背对着落日余晖。天边的晚霞映射出美丽的橘红色，"胖橘猫"的轮廓渐渐显得宁静而沉思，他的身旁放着摘下的头盔和一杯热蒸汽腾腾的咖啡。`

// 2. 根据 '分镜图图' 标识进行分割
let contentArr = content
  .split("分镜图")
  .map(
    (item) =>
      `请严格根据Prompt要求的内容绘制分镜图，分镜图描述中"xxx"描绘的信息为角色，需要严格按照角色形象进行绘制，确保角色形象拟人化绘制。画面描述：分镜图${item}`
  );
// """胖橘猫"""的外观描述为：形象应该是圆润、健壮，体现出一种成熟稳重的风范。他的毛色可能会很丰富，主要以温暖的橘色调为主。
contentArr.shift();
console.log(contentArr);

// 根据类名找到元素
let input_dom = document.querySelector(
  ".cBxR8CJK57sitcvBLt_u .semi-input-textarea.semi-input-textarea-autosize"
);

let intervalId = null;
var isStop = false;

const func = async (i = 0, cycle = 0) => {
  // 如果index已经超过数组长度，那么终止递归
  if (i >= contentArr.length) return;
  if (isStop) return;

  // 4.1. 填入内容
  let setValue = Object.getOwnPropertyDescriptor(
    window.HTMLTextAreaElement.prototype,
    "value"
  ).set;

const content = cycle === 0 ? contentArr[i] : contentArr[i].replace('分析绘制分镜图', '重新绘制分镜图')

  setValue.call(input_dom, content);

  let event = new Event("input", { bubbles: true });

  input_dom.dispatchEvent(event);

  console.time("timer");
  // 4.2. 等待2s
  await new Promise((resolve) => setTimeout(resolve, 5000));
  console.timeEnd("timer");

  // 4.3. 点击元素
  document.querySelector(".lgvvFMU_ZtEgFG2Q14nX").click();

  console.time("timer1");

  // 4.4. 等待10s，检查元素是否存在
  await new Promise(async (resolve) => {
    clearInterval(intervalId);
    intervalId = setInterval(() => {
      let isLoading =
        document.querySelector(".HtE_QDTDO5s6h3FZ5MPz").offsetHeight === 0;
    if (isStop) return;

      console.log("是否加载中: ", isLoading);
      if (isLoading) {
        clearInterval(intervalId);
        resolve();
      }
    }, 1000 * 10);
  });
  console.timeEnd("timer1");
  // 递归调用：根据cycle数，选择是进入下一循环还是进入下个内容
  cycle < 1 ? await func(i, cycle + 1) : await func(i + 1);
};

func();

