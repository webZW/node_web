
// 1. 设置内容
let content = `分镜图1
场景：早晨的小镇，街道两侧是小房子，远处有山脉轮廓，天空中温柔的朝阳正在升起，天空澄净。
"胖橘猫"：一只"胖橘猫"穿着破旧的红色毛衣，努力用两只前爪拉着一个装满各种蔬菜(如西红柿、胡萝卜和青菜)的红色小推车。
分镜图2
场景：拥挤的集市，各种蔬果和货摊排布两旁，顾客们正在挑选商品。背景有多个摊位，摆满了各色水果和蔬菜，几人围观。
"胖橘猫"：穿着相同的红色毛衣，身体微微前倾，尝试着用一袋土豆来换取一些苹果，但摊主是个满脸胡须，脸色严肃的中年人，正用手势拒绝"胖橘猫"。
分镜图3
场景：拉远镜头，"胖橘猫"坐在集市旁的阶梯上，四周有其他顾客忙碌着购物，但没有人注意到他。
"胖橘猫"：脱下红色毛衣，放在旁边的蔬菜车上，表情看起来有些失落，目光茫然地望着集市的喧嚣。
分镜图4
场景：中景，老奶奶穿着蓝白相间的格子衣，背着篮子，正在摊前购物，身后有人在交谈和走动。
"胖橘猫"和老奶奶："胖橘猫"依旧没有穿红色毛衣，正蹲在地上，老奶奶俯身将篮子里的一些食物(比如面包和奶酪)递给"胖橘猫"，他抬头看着老奶奶，眼中流露出感激的光芒。
分镜图5
场景：内部，"胖橘猫"的小屋简洁而温馨，有一扇小窗户，阳光洒在房间的一个角落，地上铺着老式的地毯。
"胖橘猫"：站在木质桌子前，穿上红色毛衣在整理食物，面前是老奶奶给的食物，包括面包、奶酪和一些新鲜的水果。"胖橘猫"的表情专注而坚定，展现他心中的希望。
分镜图6
场景：拍摄自菜园的一角，天空晴朗，阳光照耀下的一片丰富的蔬菜地，包括长势喜人的西红柿、生机勃勃的生菜和高高的玉米梗。
"胖橘猫"：带着宽边的草帽，身穿简单的蓝色背心和棕色的工作裤，蹲在菜地中间，双手戴着园艺手套，细心地给一株茄子植物除草。
分镜图7
场景：菜园的夕阳，整个菜园被黄金色的光芒所笼罩，植物的影子在泥土上拉长。
"胖橘猫"：兴奋地拿起一颗硕大的白菜，此刻他摘下了草帽，露出了得意的微笑，仿佛在向这片土地表示感谢。
分镜图8
场景：队列中站立着不同年龄和穿着的邻居们，他们手中各自拿着试吃的蔬菜，背后是"胖橘猫"小屋的外观，有蔬菜招牌。
"胖橘猫"：换上了干净的红毛衣，为了庆祝今天的收获，正在为邻居们切菜和分发，他身边是一个装满了各种蔬菜的藤篮，面带笑容，气氛热闹。
分镜图9
场景：针对"胖橘猫"的小屋内部，房间微暗，只有一个桌上的蜡烛燃烧着，旁边是打开的收支账本。
"胖橘猫"：着老式眼镜，正在桌旁认真记录账目，眼眉紧锁，脸上有着难以察觉的担忧。身上穿着简单的白色衣服，四周有一些桌上的神情，房间看起来比较杂乱。
分镜图10
场景：重回热闹的集市，人们来来往往，"胖橘猫"的摊位上现在摆满了他自己种植的新鲜蔬菜，体现了他的辛勤付出。
"胖橘猫"：穿回那件标志性的红毛衣和帽子，面带满足的笑容，正在与一位顾客交易，手中有一些硬币和纸币，交换了顾客的篮子里的食物（如熟食和水果）。
分镜图11
场景：一个温馨的集市角落，"胖橘猫"的摊位前方，摊位上摆满了各种色彩鲜艳的蔬菜，如红番茄、绿色生菜和紫色茄子，摊位上方悬挂着一块写着“"胖橘猫"的有机蔬菜”牌子。
"胖橘猫"和老奶奶：老奶奶身穿同样的格子衣，微笑着从篮子里拿出几枚硬币购买蔬菜，而"胖橘猫"手上有一本简易的记账本，正在微笑着记录交易，两人之间的微笑充满了友善和尊重。
分镜图12
场景：菜园的中心，有新的蔬菜区域正在铺排中，标志着扩建。背景有篱笆和工具，如铲子和水壶。
"胖橘猫"：穿戴着新的灰色工作帽和格子衬衫，携带园艺工具，正给一排新种下的小苗浇水。他的脸上显现出了期待和兴奋，身旁放置着一包新蔬菜种子。
分镜图13
场景：菜园被风暴的影响，蔬菜受损，支架倾斜，地面上散落着残枝败叶，天空阴沉，有大片乌云盖住了阳光。
"胖橘猫"：穿着湿漉漉的红色毛衣，站在菜园里露出焦虑的表情，眼中含着泪水看着被摧毁的菜园，但紧握的拳头表达了他的坚持与勇气。
分镜图14
场景：天空逐渐放晴，菜园里"胖橘猫"和多位邻居们正在一起工作，有的在重建支架，有的在清理残枝败叶。
"胖橘猫"：身穿蓝色长袖衬衣和棕色裤子，蹲在地上，正用手铲移除破损的植物。脸露坚定之表，四周的邻居则是一脸乐于助人，氛围团结友好。`

// 2. 根据 '分镜图图' 标识进行分割
let contentArr = content
  .split("分镜图")
  .map(
    (item) =>
      `请严格根据Prompt要求的内容绘制分镜图，分镜图描述中"xxx"描绘的信息为角色，需要严格按照角色形象进行绘制，确保角色形象拟人化绘制。画面描述：分镜图${item}`
  );
// """胖橘猫"""的外观描述为：形象应该是圆润、健壮，体现出一种成熟稳重的风范。他的毛色可能会很丰富，主要以温暖的橘色调为主。
contentArr.shift();
console.log(contentArr);

// 根据类名找到元素
let input_dom = document.querySelector(
  ".cBxR8CJK57sitcvBLt_u .semi-input-textarea.semi-input-textarea-autosize"
);

let intervalId = null;
var isStop = false;

const func = async (i = 0, cycle = 0) => {
  // 如果index已经超过数组长度，那么终止递归
  if (i >= contentArr.length) return;
  if (isStop) return;

  // 4.1. 填入内容
  let setValue = Object.getOwnPropertyDescriptor(
    window.HTMLTextAreaElement.prototype,
    "value"
  ).set;

const content = cycle === 0 ? contentArr[i] : contentArr[i].replace('分析绘制分镜图', '重新绘制分镜图')

  setValue.call(input_dom, content);

  let event = new Event("input", { bubbles: true });

  input_dom.dispatchEvent(event);

  console.time("timer");
  // 4.2. 等待2s
  await new Promise((resolve) => setTimeout(resolve, 5000));
  console.timeEnd("timer");

  // 4.3. 点击元素
  document.querySelector(".lgvvFMU_ZtEgFG2Q14nX").click();

  console.time("timer1");

  // 4.4. 等待10s，检查元素是否存在
  await new Promise(async (resolve) => {
    clearInterval(intervalId);
    intervalId = setInterval(() => {
      let isLoading =
        document.querySelector(".HtE_QDTDO5s6h3FZ5MPz").offsetHeight === 0;
    if (isStop) return;

      console.log("是否加载中: ", isLoading);
      if (isLoading) {
        clearInterval(intervalId);
        resolve();
      }
    }, 1000 * 10);
  });
  console.timeEnd("timer1");
  // 递归调用：根据cycle数，选择是进入下一循环还是进入下个内容
  cycle < 1 ? await func(i, cycle + 1) : await func(i + 1);
};

func();

