<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>点聚合</title>
  <link rel="stylesheet"  href="./geomap-api/JsCodeDemo_new/css/mapbox-gl.css" />
  <script src="./geomap-api/JsCodeDemo_new/js/mapbox-gl.js"></script>
  <script src="./geomap-api/JsCodeDemo_new/js/GeoGlobeJS.min.js"></script>
  <script src="./geomap-api/JsCodeDemo_new/js/GeoGlobeJS-Plugin.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
    }
    html,
    body,
    #map {
      height: 100%;
    }
  </style>
</head>
<body>
<div id="map"></div>
<script>
  //定义配置对象
  var map = new GeoGlobe.Map({
    container: 'map',
    zoom: 4,
    center: [117.177, 34.281]
  });

  var randomCount = 80;
  var node_data = {
    '0': { x: 108.954518, y: 34.343346 },
    '1': { x: 121.485124, y: 31.235317 }
  };
  var edge_data = [{ source: '1', target: '0' }];
  var citys = [
    '北京',
    '天津',
    '上海',
    '重庆',
    '石家庄',
    '太原',
    '呼和浩特',
    '哈尔滨',
    '长春',
    '沈阳',
    '济南',
    '南京',
    '合肥',
    '杭州',
    '南昌',
    '福州',
    '郑州',
    '武汉',
    '长沙',
    '广州',
    '南宁',
    '西安',
    '银川',
    '兰州',
    '西宁',
    '乌鲁木齐',
    '成都',
    '贵阳',
    '昆明',
    '拉萨',
    '海口'
  ];

  // 构造数据
  for (var i = 1; i < randomCount; i++) {
    var cityCenter = GeoGlobePlugin.utilCityCenter.getCenterByCityName(
            citys[parseInt(Math.random() * citys.length)]
    );
    node_data[i] = {
      x: cityCenter.lng - 5 + Math.random() * 10,
      y: cityCenter.lat - 5 + Math.random() * 10
    };
    edge_data.push({ source: ~~(i * Math.random()), target: '0' });
  }

  var fbundling = GeoGlobePlugin.utilForceEdgeBundling()
          .nodes(node_data)
          .edges(edge_data);

  var results = fbundling();
  var data = [];
  var timeData = [];

  for (var i = 0; i < results.length; i++) {
    var line = results[i];
    var coordinates = [];
    for (var j = 0; j < line.length; j++) {
      coordinates.push([line[j].x, line[j].y]);
      timeData.push({
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: [line[j].x, line[j].y]
        }
      });
    }
    data.push({
      type: 'Feature',
      geometry: {
        type: 'LineString',
        coordinates: coordinates
      }
    });
  }

  var i_i = 0,
          count = 10;

  map.on('load', function() {
    // 添加基础图层
    map.addSource('line', {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: data
      }
    });
    map.addSource('point', {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: timeData
      }
    });
    map.addLayer({
      id: 'lines',
      type: 'line',
      source: 'line',
      paint: {
        'line-color': 'rgba(55, 50, 250, 0.5)'
      }
    });
    map.addLayer({
      id: 'points',
      type: 'circle',
      source: 'point',
      paint: {
        'circle-opacity': {
          property: 'opacity',
          type: 'identity'
        },
        'circle-color': 'rgba(255, 250, 250, 0.9)',
        'circle-radius': 3,
        'circle-blur': 1
      }
    });

    // 数据刷新定时器
    setInterval(function() {
      updateProgress(i_i);
      i_i++;
    }, 50);
  });

  function updateProgress(m) {
    timeData = [];
    for (var i = 0; i < results.length; i++) {
      var line = results[i];
      for (var j = 0; j < line.length; j++) {
        var opacityData = 0.1;
        if (m <= j && j < count + m) {
          opacityData = (1 / count) * (j - m + 1);
          timeData.push({
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [line[j].x, line[j].y]
            },
            properties: {
              time: j,
              count: line.length,
              opacity: opacityData
            }
          });
        }
        if (Math.ceil(line.length / 10) + m >= line.length) {
          i_i = 0;
        }
      }
    }
    map.getSource('point').setData({
      type: 'FeatureCollection',
      features: timeData
    });
  }
</script>
</body>
</html>
